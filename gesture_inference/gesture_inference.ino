#include <Arduino.h>
#include <Wire.h>
#include "FastIMU.h"

// ===== TinyML =====
#include "gesture_model.h"      // generated by Python script
#include "gesture_model.cc"    // generated by Python script
#include <tflm_esp32.h>
#include <eloquent_tinyml.h>

// ===== Model parameters =====
#define NUM_SAMPLES 100
#define N_FEATS   6
#define INPUT_SIZE  (NUM_SAMPLES * N_FEATS)
#define OUTPUT_SIZE 2
#define ARENA_SIZE  (60 * 1024)   // adjust if needed
#define TF_NUM_OPS  6             // Dense, Relu, Softmax etc.

// ====== Buffers ======
float imu_window[NUM_SAMPLES][N_FEATS];
int sample_idx = 0;
int record = 0; 
int8_t input_buffer[NUM_SAMPLES * N_FEATS];

// ====== Normalization values (replace with training output) ======
float feat_mean[N_FEATS] = {0.71266806, -0.04217171, -0.38768274, -4.0202007,  -1.0579356,  -5.4626746};
float feat_std[N_FEATS]  = {0.29285154, 0.23960486, 0.60991544, 61.61862, 103.346214, 36.081596};

// Quantization parameters (printed in Python)
const float input_scale = 4.743627548217773f;   // example value, replace with real
const int input_zero_point = -18; // example value, replace with real

void preprocessGesture() {
  for (int i = 0; i < NUM_SAMPLES; i++) {
    for (int j = 0; j < N_FEATS; j++) {
      // 1. normalize
      float norm_val = (imu_window[i][j] - feat_mean[j]) / feat_std[j];

      // 2. quantize to int8
      int8_t q_val = (int8_t) round(norm_val / input_scale + input_zero_point);

      // store in flat buffer
      input_buffer[i * N_FEATS + j] = q_val;
    }
  }
}

// Create TinyML model wrapper
Eloquent::TF::Sequential<TF_NUM_OPS, ARENA_SIZE> tf;

// ===== IMU setup =====
#define IMU_ADDRESS 0x6B
#define PERFORM_CALIBRATION      // Comment to disable startup calibration

QMI8658 IMU;
calData   calib = {0};
AccelData accel;
GyroData  gyro;

// ===== Helper functions =====
void die(const char* msg) {
  Serial.println(msg);
  while (true) delay(100);
}

// ===== Arduino setup =====
void setup() {
  Serial.begin(115200);
  while (!Serial) {}

  Wire.begin(48, 47);
  Wire.setClock(400000);

  if (IMU.init(calib, IMU_ADDRESS) != 0)
    die("IMU init failed");

  #ifdef PERFORM_CALIBRATION
  Serial.println("FastIMU calibration & data example");
  if (IMU.hasMagnetometer()) {
    delay(1000);
    Serial.println("Move IMU in figure 8 pattern until done.");
    delay(3000);
    IMU.calibrateMag(&calib);
    Serial.println("Magnetic calibration done!");
  }
  else {
    delay(5000);
  }

  delay(5000);
  Serial.println("Keep IMU level.");
  delay(5000);
  IMU.calibrateAccelGyro(&calib);
  Serial.println("Calibration done!");
  Serial.println("Accel biases X/Y/Z: ");
  Serial.print(calib.accelBias[0]); Serial.print(", ");
  Serial.print(calib.accelBias[1]); Serial.print(", ");
  Serial.println(calib.accelBias[2]);
  Serial.println("Gyro biases X/Y/Z: ");
  Serial.print(calib.gyroBias[0]); Serial.print(", ");
  Serial.print(calib.gyroBias[1]); Serial.print(", ");
  Serial.println(calib.gyroBias[2]);
  if (IMU.hasMagnetometer()) {
    Serial.println("Mag biases X/Y/Z: ");
    Serial.print(calib.magBias[0]); Serial.print(", ");
    Serial.print(calib.magBias[1]); Serial.print(", ");
    Serial.println(calib.magBias[2]);
    Serial.println("Mag Scale X/Y/Z: ");
    Serial.print(calib.magScale[0]); Serial.print(", ");
    Serial.print(calib.magScale[1]); Serial.print(", ");
    Serial.println(calib.magScale[2]);
  }
  delay(5000);
  IMU.init(calib, IMU_ADDRESS);
  #endif

  // Setup TinyML model
  tf.setNumInputs(INPUT_SIZE);    // 600 = 100*6
  tf.setNumOutputs(OUTPUT_SIZE);  // 2 classes
  tf.resolver.AddReshape(); 
  tf.resolver.AddFullyConnected();
  tf.resolver.AddSoftmax();

  // Load the TFLite model
  while (!tf.begin(g_gesture_model_data).isOk()) {
    Serial.println(tf.exception.toString());
    delay(1000);
  }

  Serial.println("Ready. Press 'b' to capture and classify gesture.");
}

// ===== Arduino loop =====
void loop() {
  if (Serial.available() && Serial.read() == 'b') {
    Serial.println("# Capturing window...");
    record = 1; 
  }

  if(record==1){

    // Read IMU
    IMU.update();
    IMU.getAccel(&accel);
    IMU.getGyro(&gyro);

    imu_window[sample_idx][0] = accel.accelX;
    imu_window[sample_idx][1] = accel.accelY;
    imu_window[sample_idx][2] = accel.accelZ;
    imu_window[sample_idx][3] = gyro.gyroX;
    imu_window[sample_idx][4] = gyro.gyroY;
    imu_window[sample_idx][5] = gyro.gyroZ;

    sample_idx++;
    

    // Once buffer is full, run inference
    if (sample_idx >= NUM_SAMPLES) {
      sample_idx = 0;
      record = 0;

      // Run inference
      Serial.println("Preprocessing gesture");
      preprocessGesture();
      Serial.println("Inferring");
      if (!tf.predict(input_buffer).isOk()) {
        Serial.println(tf.exception.toString());
        return;
      }

      int pred = tf.classification;  // 0 or 1
      //float p0 = tf.output(0);
      //float p1 = tf.output(1);

      Serial.print("Gesture: ");
      Serial.print(pred + 1); // map back to labels 1/2
      Serial.println("");
      //Serial.print("  (p1=");
      //Serial.print(p0, 3);
      //Serial.print(", p2=");
      //Serial.print(p1, 3);
      //Serial.println(")");
    }
  }
  delay(20);  // ~50 Hz sampling, match training
}
